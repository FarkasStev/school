//[skeleton0
import java.util.*;

import visual.dynamic.described.*;
import visual.statik.TransformableContent;

/**
 * A Fish that "swims" around and avoids its "antagonists"
 * (in a simple way)
 *
 * Note: This is a simple rule-based Sprite.  Hence, it has rules in
 * handleTick().
 *
 * @author  Prof. David Bernstein, James Madison University
 * @version 1.0
 */
public class Fish extends RuleBasedSprite
{
  protected double      initialSpeed, maxX, maxY, speed, x, y;

  private static final int     INITIAL_LOCATION = -320;    
  private static final Random  rng = new Random();

  /**
   * Explicit Value Constructor
   *
   * @param content   The static visual content
   * @param width     The width of the Stage
   * @param height    The height of the Stage
   * @param speed     The normal speed
   */
  public Fish(TransformableContent content,
      double width, double height, double speed)
  {
    super(content);
    maxX = width;
    maxY = height;       

    x    = rng.nextDouble()*maxX;
    y    = rng.nextInt()*maxY;

    this.initialSpeed = speed;
    this.speed        = speed;       
  }
  //]skeleton0

  //[handleTick
  /**
   * Handle a tick event (generated by the Stage)
   *
   * @param time  The current time (which is not used)
   */
  public void handleTick(int time)
  {
    Iterator<Sprite>  i;       
    Sprite            shark;

    i = antagonists.iterator();
    while (i.hasNext())
    {          
      shark = i.next();
      if (intersects(shark)) speed = 20.;
    }

    updateLocation();
  }
  //]handleTick

  //[updateLocation
  /**
   * Update the location
   */
  protected void updateLocation()
  {
    x += speed;

    if (x > (int)maxX)
    {
      x     = INITIAL_LOCATION;
      y     = rng.nextDouble()*maxY;
      speed = initialSpeed;
    }

    // Set the location
    setLocation(x, y);
  }
  //]updateLocation
  //[skeleton1
}
//]skeleton1
