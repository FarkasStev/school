import java.util.*;

import visual.dynamic.described.*;
import visual.statik.TransformableContent;

/**
 * A Fish that "swims" in an interesting way.
 *
 * @author  Prof. David Bernstein, James Madison University
 * @version 1.0
 */
public class SwimmingFish extends RuleBasedSprite
{
	protected double      initialSpeed, maxX, maxY, speed, x, y;
	protected int         lastTime, millisPerState, state, stateChange;
	protected int         timeInState;
	protected TransformableContent[]  contents;



	private static final int     INITIAL_LOCATION = -320;    
	private static final Random  rng = new Random();

	/**
	 * Explicit Value Constructor
	 *
	 * @param contents  The static visual content
	 * @param width     The width of the Stage
	 * @param height    The height of the Stage
	 * @param speed     The normal speed
	 */
	public SwimmingFish(TransformableContent[] contents,
			double width, double height, double speed)
	{
		super(contents[0]);

		this.contents = contents;

		maxX = width;
		maxY = height;       

		x    = rng.nextDouble()*maxX;
		y    = rng.nextInt()*maxY;

		this.initialSpeed = speed;
		this.speed        = speed;       
		state             = 0;       
		lastTime          = 0;
		timeInState       = 0;       
		stateChange       = 1;       
	}


	/**
	 * Get the visual content associated with this Sprite
	 * (required by Sprite)
	 */
	public TransformableContent getContent()
	{
		return contents[state];
	}


	/**
	 * Handle a tick event (generated by the Stage)
	 *
	 * @param time  The current time (which is not used)
	 */
	public void handleTick(int time)
	{
		Iterator<Sprite>  i;       
		Sprite            shark;

		i = antagonists.iterator();
		while (i.hasNext())
		{          
			shark = i.next();       
			if (intersects(shark)) speed = 20.;
		}

		millisPerState    = 500 - (int)(speed*20);       

		timeInState += (time - lastTime);
		if (timeInState > millisPerState)
		{
			timeInState = 0;
			state += stateChange;
			if      (state == 2) stateChange = -1;
			else if (state == 0) stateChange =  1;
		}
		lastTime = time;       

		updateLocation();
	}


	/**
	 * Update the location
	 */
	protected void updateLocation()
	{
		x += speed;

		if (x > (int)maxX)
		{
			x     = INITIAL_LOCATION;
			y     = rng.nextDouble()*maxX;
			speed = initialSpeed;          
		}

		// Set the location
		setLocation(x, y);
	}
}
