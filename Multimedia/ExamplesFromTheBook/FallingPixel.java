import java.awt.*;
import java.awt.geom.*;
import java.util.Random;

import visual.dynamic.described.*;
import visual.statik.described.*;

/**
 * A pixel that falls from the top of the screen to its
 * correct location in an image
 *
 * Note: This is a simple rule-based Sprite.  It does not use key-frames
 * or tweening.  Hence, it has rules in handleTick().
 *
 * @author  Prof. David Bernstein, James Madison University
 * @version 1.0
 */
public class FallingPixel extends AbstractSprite
{
  private Color      color;    
  private int        finalX, finalY, speed, y;

  private static final Random    rng = new Random();

  /**
   * Explicit Value Constructor
   *
   * @param color    The color of the pixel
   * @param finalX   The x-position of the pixel in the image
   * @param finalY   The y-position of the pixel in the image
   */
  public FallingPixel(Color color, int finalX, int finalY)
  {
    super();
    this.color = color;
    this.finalX = finalX;
    this.finalY = finalY;

    y = -1 * rng.nextInt(200);
    speed = 1 + rng.nextInt(3);

    setVisible(true);
  }

  /**
   * Gets the (current) visual content for this Sprite
   * (required by Sprite)
   *
   * Note: This method is not used since render() is
   * overridden.  It is included to honot the contract
   * specified in Sprite
   */
  public TransformableContent getContent()
  {
    return null;
  }

  /**
   * Handle a tick event (generated by the Stage)
   *
   * @param time  The current time (which is not used)
   */
  public void handleTick(int time)
  {
    // Update the location
    if (y < finalY) y += speed;
    else            y = finalY;
  }

  /**
   * Return the bounding box of the Sprite as it will be rendered
   * (i.e., after being transformed).
   *
   * @return  The bounding box
   */
  public Rectangle2D getBounds2D()
  {
    return null;
  }

  /**
   * Render the Sprite in its current state
   *
   * Note: This class does not use AffineTransform objects
   * to "move" the Sprite before rendering it (which is slow).
   * Instead, it simply renders the Sprite at the appropriate
   * location (which is much faster). 
   *
   * @param g  The rendering engine to use
   */
  public void render(Graphics g)
  {
    Graphics2D        g2;

    if (y > 0)
    {
      g2 = (Graphics2D)g;       
      g2.setColor(color);

      g2.drawLine(finalX, y, finalX, y);
    }
  }
}
